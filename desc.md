Návrh riešenia: nástroj v Pythone na odhalenie nepoužívaných ViewModel metód

Keďže neexistuje hotové riešenie, je vhodné navrhnúť vlastný nástroj (napríklad v Pythone), ktorý prejde celý projekt a vygeneruje zoznam nepoužívaných ViewModel tried a metód. Nižšie sú hlavné body, na ktoré sa takýto nástroj musí zamerať, aby spoľahlivo zistil, či je metóda použitá alebo ju možno odstrániť:
	•	Identifikácia ViewModel tried: Nástroj najprv prehľadá všetky Java zdrojové súbory a vyfiltruje triedy patriace ViewModel vrstve. V jednoduššom prípade sa dá určiť podľa názvu (napr. všetky triedy končiace na ViewModel alebo v špecifickom balíčku). Prípadne možno zahrnúť aj abstraktné základné triedy ViewModelov, ak existujú. Pre každú takto nájdenú triedu si nástroj poznačí jej meno a plne kvalifikovaný názov.
	•	Zoznam verejných metód: Pre každú ViewModel triedu nástroj extrahuje všetky jej verejné metódy (public). Dôležité je zahrnúť aj metódy zdedené a preťažené?
	•	Pokiaľ je cieľom nájsť kandidátov na vymazanie, zvyčajne nás zaujímajú vlastné metódy ViewModelu (vrátane verejných getterov a setterov vlastností). Metódy zdedené z Object (toString(), equals()…) alebo z frameworku možno ignorovať, keďže ich prítomnosť je daná (a ak sú override, predpokladáme, že ich override má nejaký dôvod alebo by ich aspoň statická analýza tiež zachytila ako nevolané).
	•	Rovnako treba zohľadniť ZK anotácie: metódy označené anotáciami životného cyklu ako @Init alebo @AfterCompose nesmú byť považované za nepoužité, aj keby na ne neukazovala žiadna iná referencia. Tieto totiž volá ZK framework automaticky pri vytváraní a kompozícii viewmodelu. (Podobne aj @Destroy alebo iné event-callback anotácie, ak sa používajú.)
	•	Navyše, ak by vo ViewModel triede existovali statické verejné metódy (neobvyklé, ale možné), tie tiež treba zachytiť – hoci v MVVM architektúre by nemali byť volané z UI priamo.
	•	Analýza referencií v Java kóde: Nástroj prejde celý Java kód projektu a hľadá použitia každej zo zoznamu verejných metód:
	•	Priame volania v kóde: pomocou parsera alebo jednoduchšie aj textovým vyhľadávaním musí nájsť všetky výskyty NázovMetódy( v .java súboroch, ktoré nie sú len deklaráciou. Optimálne je použiť AST parser pre Javu (prípadne existuje Python knižnica ako javalang alebo volať Java parser cez napr. javaparser), aby vedel rozlíšiť, či volaná metóda patrí danej ViewModel triede.
	•	Napríklad, ak máme metódu saveOrder() vo OrderViewModel, parser by našiel volania obj.saveOrder( alebo OrderViewModel.saveOrder( v celom projekte.
	•	Nástroj takto označí metódu ako použitú, ak nájde aspoň jeden výskyt volania v kóde (mimo jej vlastnej definície). Započítavajú sa aj volania v testovacích triedach (hoci tie možno chcieť reportovať osobitne – niektoré tímy považujú metódu používanú len v teste stále za kandidáta na odstránenie v produkčnom kóde ￼).
	•	Reflexia a reťazce v kóde: nástroj by mal vyhľadať aj možné reflexívne použitia – napr. či niekde v kóde nie je volané Class.forName("...ViewModel") alebo getMethod("nazovMetody"). Tieto prípady sú zriedkavé, ale ak by existovali (napr. dynamické volanie príkazov), treba ich zachytiť. Dá sa to heuristicky – hľadať výskyty mena metódy ako reťazca v celom projekte. Ak by napríklad iný komponent volal BindUtils.postGlobalCommand(..., "refresh", ...), tak reťazec "refresh" môže odkazovať na metódu vo ViewModel s anotáciou @GlobalCommand(name="refresh"). Preto je vhodné hľadať aj mená metód v textových literáloch. (Tu však môže byť veľa falošných nálezov – napr. slovo refresh môže byť aj súčasťou textu UI.)
	•	Lepším prístupom je kombinovať to s vedomosťou o anotáciách: najprv zistiť, ktoré metódy sú označené @GlobalCommand (prípadne @Command s explicitným menom). Ak napr. nájdeme vo viewmodeli @GlobalCommand("refresh") public void refreshData(){...}, tak budeme hľadať výskyt "refresh" v kontexte volania globálneho príkazu (metódy postGlobalCommand, alebo v ZUL ako @global-command('refresh')).
	•	Inštancia ViewModel v kóde: Okrem volania metód nástroj skontroluje, či daná trieda ViewModel nie je konštruovaná alebo používaná v kóde (napr. new SomeViewModel() alebo autowirovaná cez Spring a pod.). Ak áno, tak samotná trieda je použitá (nemala by sa zmazať), aj keby konkrétne metódy neboli volané. Ale v takom prípade sa možno volajú jej metódy priamo, čo by už malo byť zachytené.
	•	Tu ide skôr o identifikáciu celých tried, ktoré nie sú nikde ani vytvorené, ani odkazované. Také triedy by boli úplne mŕtve (napr. zabudnuté ViewModely po refaktoringu). Ich detekcia je jednoduchšia – ak názov triedy (alebo jej plný názov) nikde nevystupuje v projekte (v Java kóde ani v ZUL súboroch), danú triedu možno pravdepodobne odstrániť celú.
	•	Analýza ZUL šablón: Toto je kľúčová časť nástroja, pretože ZUL súbory definujú datové väzby a udalosti, ktoré môžu volať ViewModel metódy:
	•	Prehľadanie súborov .zul: Nástroj rekurzívne prejde všetky ZUL šablóny v projekte. Každý ZUL sa dá parsovať ako XML (napr. použiť Python knižnicu xml.etree.ElementTree alebo BeautifulSoup pre HTML/XML), čo umožní systematicky prechádzať elementy a ich atribúty.
	•	Identifikácia ViewModel v ZUL: Najskôr zistí, či ZUL obsahuje napojenie viewmodelu, typicky cez atribút viewModel="@id('vm') @init('full.class.Name')" na koreňovom elemente (window/div a pod.). Z neho vie extrahovať plný názov triedy, ktorú ZUL používa ako ViewModel. Tým sa zmapuje konkrétny ZUL k príslušnej ViewModel triede.
	•	Ak niektorý ViewModel nie je nikde spomenutý v žiadnom ZUL (ani v kóde), je to kandidát na odstránenie celej triedy.
	•	Niektoré ZUL môžu viewmodel inicializovať programovo alebo cez iný mechanizmus (napr. v Spring prostredí cez @init(springBean('beanName'))). V takom prípade je v ZUL aspoň uvedený id, takže budeme vedieť, že ten ZUL používa istú triedu (aj keď trieda môže byť definovaná ako Spring bean, meno triedy by malo byť zrejmé v definícii beanu alebo priamo v .zul).
	•	Dátové väzby a volania v ZUL: Pre každý ZUL, ktorý má priradený viewmodel, nástroj prehľadá všetky atribúty relevantné pre MVVM:
	•	Príkazy (@command): Hľadať atribúty v tvare @command('názov') alebo @global-command('názov'). Hodnoty v apostrofoch sú mená príkazov.
	•	Každý takýto názov príkazu porovnať s metódami príslušnej ViewModel triedy. Podľa ZK konvencie, ak metóda vo viewmodeli má anotáciu @Command bez explicitného mena, názov príkazu sa rovná názvu metódy ￼. Ak anotácia obsahuje meno, používa sa to. Nástroj by teda mohol pre každú verejnú metódu s anotáciou @Command/@GlobalCommand poznať jej príkazové meno (buď priamo metóda, alebo hodnotu v zátvorke).
	•	Keď nájde v ZUL @command('save'), priradí to ako použitie metódy s názvom (alebo príkazovým menom) save v danom viewmodeli. Zápis @global-command('xyz') podobne značí použitie globálneho príkazu xyz – nástroj musí nájsť, ktorá trieda a metóda tomu zodpovedá (napr. iný ViewModel v tej istej stránke, alebo aj v inej, ak komunikujú globálne). Preto by si mal vopred zozbierať všetky metódy s @GlobalCommand menami a ak v ľubovoľnom ZUL vidí @global-command('XYZ'), označí metódu XYZ v každej ViewModel triede, ktorá ju definuje, za použitú. (Poznámka: Ak je viac viewmodelov v jednej stránke – pr. mainVM a listVM, zvyčajne @global-command('refresh') na tlačidle pre mainVM cieli refresh metódu v listVM. Nástroj by to mohol vydedukovať, ak pozná, že listVM má metódu s @GlobalCommand("refresh"). Čiže treba globálne sk cross-referenciu príkazov.)
	•	Väzby vlastností (@load/@bind): Hľadať výskyty výrazov obsahujúcich názov viewmodelu (podľa jeho @id hodnoty, často "vm") a následne názov nejakej property alebo metódy:
	•	Formát môže byť value="@load(vm.property)", selected="@bind(vm.selectedItem)", prípadne aj volanie metódy napr. label="@load(vm.computeLabel(item))".
	•	Nástroj musí rozlišovať, či výraz odkazuje na property alebo volá metódu. Heuristika: ak za vm. nasleduje identifikátor a potom otváracia zátvorka (, ide o volanie metódy. Napríklad vm.computeLabel( znamená, že sa volá metóda computeLabel(...) viewmodelu. Takúto metódu označíme ako použitú (v danom viewmodeli).
	•	Ak za vm. nasleduje identifikátor a žiadna zátvorka (alebo len uzatváracia zátvorka pre celý výraz), ide o jednoduchý prístup k property – čiže volá sa príslušný getter. Napr. vm.index v @bind(vm.index) vyústi do volania metódy getIndex() ￼. Nástroj teda musí preložiť názov property na metódu: pre vm.index hľadá v danom viewmodeli getIndex() alebo isIndex() (pre boolean) a tú označí za použitú. Rovnako ak sa v ZUL vyskytuje zápis, ktorý ukladá hodnotu do property (napr. @save(vm.name) alebo @bind(vm.name) v dvojväzbovom režime), znamená to, že bude použitý aj setter setName(...). Preto všetky páry getter/setter pre väzby považujeme za použité, ak daná property figuruje v akomkoľvek data binding výraze.
	•	Nástroj by mal pokryť aj zložitejšie EL výrazy v ZUL: napríklad vo widgetoch ako <label value="@load(vm.address.street)"/> je vnorený prístup k property JavaBean-u (vm.address je objekt s getterom getAddress(), následne sa volá jeho getStreet()). Mal by preto označiť aj getAddress() v viewmodeli, aj getStreet() v triede Address ako použité. (Avšak analyzovať detailne reťazec vm.address.street do tej miery už presahuje rámec potrebný len na ViewModel metódy – stačí nám označiť getAddress() na strane viewmodelu.)
	•	Nezabudnúť na zbierkové property: ak ZUL používa <listbox model="@load(vm.items)"/>, volá getItems(). Tiež ak je v ZUL napr. forEach alebo iné templatové prvky viazané na kolekciu, to všetko smeruje opäť na getter property. Každý výskyt vm.nieco treba považovať za použitie getNieco() (a potenciálne setNieco() ak sa daná hodnota ukladá späť).
	•	ZK skripty a iné eventy: Nástroj musí zohľadniť aj prípadné použitia v <zscript> blokoch v ZUL (kde môže byť priamo volaný Java kód). Napríklad, ak v zscript je vm.doSomething();, to je priame volanie metódy. Také niečo je v MVVM zriedkavé (MVVM sa snaží vylúčiť zscript), ale ak tam je, treba to nájsť. Podobne starší štýl event handlerov v ZUL (nie MVVM) by bol onClick="doSomething()" priamo na komponente – to by volalo metódu v composer triede, nie vo viewmodeli, takže to asi netreba riešiť pre MVVM viewmodely.
	•	Inkludované ZUL a kompozície: Ak projekt používa  alebo , treba dať pozor, že inkludovaný zul môže alebo nemusí mať vlastný viewmodel. Často zdedí viewmodel od rodičovského komponentu (napr. param viewModel sa môže preniesť). Nástroj by preto pri spracovaní ZUL mal všímať, či v includovanom súbore chýba viewModel definícia. V takom prípade predpokladáme, že používa ten istý viewmodel ako parent – takže ak v subPage.zul vidíme referenciu vm.someMethod, ale subPage.zul nemá vlastné @init, znamená to, že someMethod patrí viewmodelu rodičovskej stránky. Nástroj by mohol zistiť, kto ho includuje (napr. vyhľadá v projekte, kde sa <include src="subPage.zul"/> vyskytuje a ak tam je viewModel definovaný, priradí referencie tomu). Toto je už pokročilá úloha – v prvej fáze možno predpokladať 1 ZUL = 1 ViewModel pre zjednodušenie, a zložité prípady doladiť neskôr.
	•	Vyhodnotenie nepoužívaných metód: Po zozbieraní všetkých možných odkazov nástroj spraví krížovú kontrolu:
	•	Každú verejnú metódu v každom ViewModel porovná so zoznamom zistených použití. Ak sa nenašla žiadna referencia (ani v Java kóde, ani v žiadnom ZUL, skripte či väzbe) a metóda nemá ani osobitnú úlohu (nie je to @Init, @AfterCompose atď.), potom ju označí ako nepoužívanú.
	•	Ak je celá trieda ViewModel takto bez využitia (žiaden ZUL ju neinituje a žiaden kód ju nevolá), nástroj to zvýrazní – takú triedu možno zrejme odstrániť celú.
	•	Nájdené nepoužívané metódy vypíše napríklad formou zoznamu: uvedie názov triedy a pod ňou odrážkovo metódy na odstránenie. Prípadne ku každej metóde môže pridať dôvod či kontext, napríklad:
	•	OrderViewModel: public void cancelOrder() – nepoužívaná (žiadny výskyt v kóde ani ZUL)
	•	UserViewModel: public String formatName(User u) – nepoužívaná (žiadna väzba v ZUL, ani interné volanie).
	•	Výstupom môže byť aj súbor (napr. CSV alebo Markdown report) pre lepšiu čitateľnosť. Cieľom je, aby vývojár dostal konkrétny zoznam kandidátov na zmazanie. To je vlastne aj implicitný návrh na odstránenie – nástroj tým navrhne: “Tieto metódy/triedy pravdepodobne môžete odstrániť, keďže v projekte nemajú využitie.”
	•	Pre väčšiu istotu môže nástroj kľudne uvádzať aj počet nájdených referencií pre každú metódu (očakáva sa 0 pre tie, čo chceme odstrániť). Napr. ak by našiel 1 referenciu, metódu do reportu nezaradí, inak zaradí.
	•	Ošetrenie špeciálnych prípadov: Ako posledný krok (prípadne súčasť vyhodnotenia) treba zvážiť:
	•	Metódy označené anotáciami @Command, @GlobalCommand, ktoré sa nikde neviažu v ZUL: teoreticky sú nepotrebné (zrejme zabudnuté po refaktoringu UI). Nástroj ich správne identifikuje ako nepoužité, no vývojár by mal manuálne potvrdiť, či naozaj nejde o funkcionalitu, ktorú napr. plánovali používať. (Anotácia sama o sebe neznamená použitie – binder ju volá len ak existuje príkaz v UI ￼.)
	•	Metódy @DefaultCommand alebo @DefaultGlobalCommand: tie môžu byť volané iba v prípade, že príde príkaz, na ktorý neexistuje iná metóda ￼ ￼. Ak nikdy neprichádza neznámy príkaz, default metóda sa nevolá – ale zvykom je ponechať ju ako bezpečnostnú sieť. Nástroj by ju však vyhodnotil ako nepoužitú. Je na zvážení, či takéto metódy zahrnúť do reportu – možno áno, s poznámkou, že ide o default handler, ktorý sa volá len vo výnimočnom prípade.
	•	Dedene metódy: Ak viac ViewModelov dedí od spoločnej nadtriedy (napr. BaseViewModel), ktorá obsahuje nejaké verejné metódy, tie sa môžu volať aj na potomkoch. Nástroj by mohol nesprávne označiť metódu v BaseViewModel ako nepoužitú, hoci ju volajú deti. Preto by mal brať do úvahy, že ak potomok je používaný a neoverride-uje danú metódu, volanie môže smerovať na predka. Riešenie: buď nezahŕňať abstraktné/základné triedy do analýzy alebo pri nájdení volania metódy na instanciu potomka považovať aj predkovu implementáciu za použitú. Toto je pomerne zložitá logika, takže v prvej iterácii môže nástroj jednoducho vynechať abstraktné viewmodely z reportu, resp. označiť výsledky v nich ako potrebné manuálne overiť.
	•	Spring zrna a dependency injection: Ak sú ViewModely spravované Springom, mohli by byť používané i mimo ZUL (cez volania iných beanov). To by ale znamenalo, že iné beany ich majú injektované a volajú – čo by nástroj našiel pri prehľadávaní Java kódu (volania metód alebo aspoň použitia triedy). Pokiaľ nie, tak bean je registrovaný ale nepoužitý – čo je opäť kandidát na odstránenie. (Spring samostatne nevolá metódy viewmodelov, iba ich môže udržiavať ako singletony atď.)

Zhrnutie: Takýto Python nástroj by výrazne uľahčil identifikáciu mŕtveho kódu po refaktorovaní ZUL šablón. Prejde celý projekt, spojí informácie z Java aj ZUL častí a vypíše zoznam verejných metód ViewModelov, ktoré nemajú žiadne použitie ani v kóde, ani v dátových väzbách či príkazoch. Tieto metódy (a v niektorých prípadoch celé triedy) je potom možné bezpečne odstrániť, čím sa projekt vyčistí od neudržiavaného kódu. Samozrejme, výsledky treba pred mazaním ešte potvrdiť (ideálne napr. spustením testov po odstránení) – no nástroj výrazne zúži okruh hľadaného kódu.

Výsledný report tak poskytne konkrétny návrh na odstránenie: identifikuje nevyužité metódy a triedy. Napríklad: „ViewModel XYZ – metódy a(), b(), c() sú nevolané; ViewModel ABC sa nikde nepoužíva.“ To vývojárom umožní sústrediť sa na kontrolu a elimináciu práve týchto častí. Vzhľadom na veľkosť kódu (80+ viewmodelov, tisíce súborov) takýto nástroj zásadne zefektívni refaktoring – minimalizuje ručné prehľadávanie a pomáha predísť prehliadnutiu “mŕtveho” kódu.

Poznámka: Implementácia musí byť dôkladne otestovaná, aby pokryla všetky spomenuté scenáre (ZK binding, ZEL výrazy, skripty, globálne príkazy atď.), inak by mohlo dôjsť k nesprávnej identifikácii. No už samotný koncept vychádza z dokumentovaného správania ZK – napr. binder volá metódy podľa mien príkazov ￼ a vlastnosti podľa getterov ￼ – takže vieme presne, čo hľadať. Správne navrhnutý nástroj teda umožní spoľahlivo vyčistiť projekt od nepoužívaných ViewModel metód.
